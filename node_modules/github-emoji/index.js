"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const emoji_json_1 = __importDefault(require("./emoji.json"));
exports.URLS = emoji_json_1.default;
const path_1 = require("path");
let cache = null;
let stringToName = null;
const IMAGES_BASE = path_1.join(__dirname, 'images');
const RE_HEX = /^[0-9a-f-]+$/;
function fileOf(url) {
    return url.slice(url.lastIndexOf('/') + 1, url.lastIndexOf('?'));
}
function strOf(file) {
    const base = path_1.basename(file, '.png');
    if (!RE_HEX.test(base)) {
        return null;
    }
    if (!base.includes('-')) {
        return String.fromCodePoint(parseInt(base, 16));
    }
    return String.fromCodePoint(...base.split('-').map(s => parseInt(s, 16)));
}
function emojiOf(name) {
    const url = emoji_json_1.default[name];
    const file = fileOf(url);
    return {
        name,
        url,
        file,
        path: path_1.join(IMAGES_BASE, file),
        string: strOf(file),
    };
}
function buildStringToName(checkEmoji) {
    stringToName = new Map();
    let ret = [];
    for (const [name, info] of all().entries()) {
        if (info.string !== null) {
            let arr = stringToName.get(info.string);
            if (arr === undefined) {
                arr = [name];
                stringToName.set(info.string, arr);
            }
            else {
                arr.push(name);
            }
            if (info.string === checkEmoji) {
                ret = arr;
            }
        }
    }
    return ret;
}
function isEmoji(emoji) {
    if (stringToName !== null) {
        return stringToName.has(emoji);
    }
    return buildStringToName(emoji).length > 0;
}
exports.isEmoji = isEmoji;
function nameOf(emoji) {
    const names = namesOf(emoji);
    if (names.length === 0) {
        return null;
    }
    return names[0];
}
exports.nameOf = nameOf;
function namesOf(emoji) {
    if (stringToName !== null) {
        const name = stringToName.get(emoji);
        return name || [];
    }
    return buildStringToName(emoji);
}
exports.namesOf = namesOf;
function isName(name) {
    return name in emoji_json_1.default;
}
exports.isName = isName;
function stringOf(name) {
    if (!(name in emoji_json_1.default)) {
        throw new Error(`Emoji named '${name}' not found`);
    }
    if (cache !== null) {
        return cache.get(name).string;
    }
    return strOf(fileOf(emoji_json_1.default[name]));
}
exports.stringOf = stringOf;
function of(name) {
    if (!(name in emoji_json_1.default)) {
        throw new Error(`Emoji named '${name}' not found`);
    }
    if (cache !== null) {
        return cache.get(name);
    }
    return emojiOf(name);
}
exports.of = of;
function all() {
    if (cache !== null) {
        return cache;
    }
    cache = new Map();
    for (const key of Object.keys(emoji_json_1.default)) {
        cache.set(key, emojiOf(key));
    }
    return cache;
}
exports.all = all;
//# sourceMappingURL=index.js.map